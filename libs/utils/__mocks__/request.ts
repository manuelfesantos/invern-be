import { HttpMethodEnum } from "@http-entity";
import { CountriesEndpointProtectedData, Env } from "@request-entity";
import { undefined } from "zod";
import { Country } from "@country-entity";

// eslint-disable-next-line max-len
const edgeRequestKeepAliveStatus: IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus = 0;

const country: Iso3166Alpha2Code = "PT";

const envMock: Env = {
  INSERT_TEST_DATA_SECRET: "",
  INVERN_DB: {} as D1Database,
  REFRESH_TOKEN_SECRET: "",
  SENDGRID_API_KEY: "",
  SETUP_COUNTRIES_SECRET: "",
  SETUP_STOCK_SECRET: "",
  STOCK_BUCKET: {} as R2Bucket,
  STOCK_HOST: "",
  STRIPE_API_KEY: "",
  TOKEN_SECRET: "",
  ZONE_ID: "",
  STRIPE_ENV: "",
  ENV: "test",
  COUNTRIES_BUCKET: {} as unknown as R2Bucket,
  AUTH_KV: {} as unknown as KVNamespace<string>,
  CACHE_API_EMAIL: "",
  CACHE_API_KEY: "",
  COUNTRIES_HOST: "",
  FRONTEND_HOST: "",
  HONEYCOMB_API_KEY: "",
  HONEYCOMB_DATASET: "",
};

const dataMock: CountriesEndpointProtectedData & {
  honeycomb: { tracer: { addData: () => void } };
} = {
  accessToken: "",
  cartId: "cartId",
  country: {} as unknown as Country,
  honeycomb: {
    tracer: {
      addData: function () {},
    },
  },
  refreshToken: "refreshToken",
  remember: false,
  userId: "userId",
};

export const GETEventMock = {
  data: dataMock,
  env: {
    ...envMock,
    ASSETS: {
      fetch: jest.fn(),
    },
  },
  functionPath: "http://localhost:3000",
  next: jest.fn(),
  params: {},
  passThroughOnException: jest.fn(),
  request: {
    headers: {
      get: jest.fn(),
      getAll: jest.fn(),
      entries: jest.fn(),
      has: jest.fn(),
      set: jest.fn(),
      delete: jest.fn(),
      forEach: jest.fn(),
      keys: jest.fn(),
      values: jest.fn(),
      append: jest.fn(),
      [Symbol.iterator]: jest.fn(),
    },
    json: jest.fn(),
    text: jest.fn(),
    clone: jest.fn(),
    method: HttpMethodEnum.GET,
    url: "http://localhost:3000",
    bytes: undefined as unknown as () => Promise<Uint8Array>,
    redirect: "false",
    fetcher: {
      fetch: jest.fn(),
      connect: jest.fn(),
    },
    signal: {
      aborted: false,
      dispatchEvent: jest.fn(),
      addEventListener: jest.fn(),
      onabort: jest.fn(),
      removeEventListener: jest.fn(),
      throwIfAborted: jest.fn(),
      reason: undefined,
    },
    body: new ReadableStream({}),
    arrayBuffer: jest.fn(),
    blob: jest.fn(),
    bodyUsed: false,
    formData: jest.fn(),
    cf: {
      asn: 0,
      colo: "",
      country,
      asOrganization: "",
      botManagement: {
        corporateProxy: false,
        detectionIds: [],
        ja3Hash: "",
        verifiedBot: false,
        score: 0,
        staticResource: false,
      },
      city: "lisbon",
      clientTrustScore: 0,
      requestPriority: "",
      edgeRequestKeepAliveStatus,
      hostMetadata: {
        id: 0,
        name: "",
        region: "",
        status: "",
        type: "",
        __typename: "",
      },
      httpProtocol: "HTTP/1.1",
      tlsCipher: "",
      tlsVersion: "",
      tlsClientAuth: {
        certFingerprintSHA1: "",
        certFingerprintSHA256: "",
        certIssuerDN: "",
        certIssuerDNLegacy: "",
        certIssuerDNRFC2253: "",
        certIssuerSerial: "",
        certIssuerSKI: "",
        certNotAfter: "",
        certNotBefore: "",
        certPresented: "1" as const,
        certRevoked: "0" as const,
        certSerial: "",
        certSKI: "",
        certSubjectDN: "",
        certSubjectDNLegacy: "",
        certSubjectDNRFC2253: "",
        certVerified: "SUCCESS" as const,
      },
    },
    integrity: "",
    keepalive: false,
  },
  waitUntil: jest.fn(),
};
export const POSTEventMock = {
  data: dataMock,
  env: {
    ...envMock,
    ASSETS: {
      fetch: jest.fn(),
    },
  },
  functionPath: "http://localhost:3000",
  next: jest.fn(),
  params: {},
  passThroughOnException: jest.fn(),
  request: {
    headers: {
      get: jest.fn(),
      getAll: jest.fn(),
      entries: jest.fn(),
      has: jest.fn(),
      set: jest.fn(),
      delete: jest.fn(),
      forEach: jest.fn(),
      keys: jest.fn(),
      values: jest.fn(),
      append: jest.fn(),
      [Symbol.iterator]: jest.fn(),
    },
    json: jest.fn(),
    text: jest.fn(),
    clone: jest.fn(),
    method: HttpMethodEnum.POST,
    url: "http://localhost:3000",
    bytes: undefined as unknown as () => Promise<Uint8Array>,
    redirect: "false",
    fetcher: {
      fetch: jest.fn(),
      connect: jest.fn(),
    },
    signal: {
      aborted: false,
      dispatchEvent: jest.fn(),
      addEventListener: jest.fn(),
      onabort: jest.fn(),
      removeEventListener: jest.fn(),
      throwIfAborted: jest.fn(),
      reason: undefined,
    },
    body: new ReadableStream({}),
    arrayBuffer: jest.fn(),
    blob: jest.fn(),
    bodyUsed: false,
    formData: jest.fn(),
    cf: {
      asn: 0,
      colo: "",
      country,
      asOrganization: "",
      botManagement: {
        corporateProxy: false,
        detectionIds: [],
        ja3Hash: "",
        verifiedBot: false,
        score: 0,
        staticResource: false,
      },
      city: "lisbon",
      clientTrustScore: 0,
      requestPriority: "",
      edgeRequestKeepAliveStatus,
      hostMetadata: {
        id: 0,
        name: "",
        region: "",
        status: "",
        type: "",
        __typename: "",
      },
      httpProtocol: "HTTP/1.1",
      tlsCipher: "",
      tlsVersion: "",
      tlsClientAuth: {
        certFingerprintSHA1: "",
        certFingerprintSHA256: "",
        certIssuerDN: "",
        certIssuerDNLegacy: "",
        certIssuerDNRFC2253: "",
        certIssuerSerial: "",
        certIssuerSKI: "",
        certNotAfter: "",
        certNotBefore: "",
        certPresented: "1" as const,
        certRevoked: "0" as const,
        certSerial: "",
        certSKI: "",
        certSubjectDN: "",
        certSubjectDNLegacy: "",
        certSubjectDNRFC2253: "",
        certVerified: "SUCCESS" as const,
      },
    },
    integrity: "",
    keepalive: false,
  },
  waitUntil: jest.fn(),
};
export const PUTEventMock = {
  data: dataMock,
  env: {
    ...envMock,
    ASSETS: {
      fetch: jest.fn(),
    },
  },
  functionPath: "http://localhost:3000",
  next: jest.fn(),
  params: {},
  passThroughOnException: jest.fn(),
  request: {
    headers: {
      get: jest.fn(),
      getAll: jest.fn(),
      entries: jest.fn(),
      has: jest.fn(),
      set: jest.fn(),
      delete: jest.fn(),
      forEach: jest.fn(),
      keys: jest.fn(),
      values: jest.fn(),
      append: jest.fn(),
      [Symbol.iterator]: jest.fn(),
    },
    json: jest.fn(),
    text: jest.fn(),
    clone: jest.fn(),
    method: HttpMethodEnum.PUT,
    url: "http://localhost:3000",
    bytes: undefined as unknown as () => Promise<Uint8Array>,
    redirect: "false",
    fetcher: {
      fetch: jest.fn(),
      connect: jest.fn(),
    },
    signal: {
      aborted: false,
      dispatchEvent: jest.fn(),
      addEventListener: jest.fn(),
      onabort: jest.fn(),
      removeEventListener: jest.fn(),
      throwIfAborted: jest.fn(),
      reason: undefined,
    },
    body: new ReadableStream({}),
    arrayBuffer: jest.fn(),
    blob: jest.fn(),
    bodyUsed: false,
    formData: jest.fn(),
    cf: {
      asn: 0,
      colo: "",
      country,
      asOrganization: "",
      botManagement: {
        corporateProxy: false,
        detectionIds: [],
        ja3Hash: "",
        verifiedBot: false,
        score: 0,
        staticResource: false,
      },
      city: "lisbon",
      clientTrustScore: 0,
      requestPriority: "",
      edgeRequestKeepAliveStatus,
      hostMetadata: {
        id: 0,
        name: "",
        region: "",
        status: "",
        type: "",
        __typename: "",
      },
      httpProtocol: "HTTP/1.1",
      tlsCipher: "",
      tlsVersion: "",
      tlsClientAuth: {
        certFingerprintSHA1: "",
        certFingerprintSHA256: "",
        certIssuerDN: "",
        certIssuerDNLegacy: "",
        certIssuerDNRFC2253: "",
        certIssuerSerial: "",
        certIssuerSKI: "",
        certNotAfter: "",
        certNotBefore: "",
        certPresented: "1" as const,
        certRevoked: "0" as const,
        certSerial: "",
        certSKI: "",
        certSubjectDN: "",
        certSubjectDNLegacy: "",
        certSubjectDNRFC2253: "",
        certVerified: "SUCCESS" as const,
      },
    },
    integrity: "",
    keepalive: false,
  },
  waitUntil: jest.fn(),
};
export const DELETEEventMock = {
  data: dataMock,
  env: {
    ...envMock,
    ASSETS: {
      fetch: jest.fn(),
    },
  },
  functionPath: "http://localhost:3000",
  next: jest.fn(),
  params: {},
  passThroughOnException: jest.fn(),
  request: {
    headers: {
      get: jest.fn(),
      getAll: jest.fn(),
      entries: jest.fn(),
      has: jest.fn(),
      set: jest.fn(),
      delete: jest.fn(),
      forEach: jest.fn(),
      keys: jest.fn(),
      values: jest.fn(),
      append: jest.fn(),
      [Symbol.iterator]: jest.fn(),
    },
    json: jest.fn(),
    text: jest.fn(),
    clone: jest.fn(),
    method: HttpMethodEnum.DELETE,
    url: "http://localhost:3000",
    bytes: undefined as unknown as () => Promise<Uint8Array>,
    redirect: "false",
    fetcher: {
      fetch: jest.fn(),
      connect: jest.fn(),
    },
    signal: {
      aborted: false,
      dispatchEvent: jest.fn(),
      addEventListener: jest.fn(),
      onabort: jest.fn(),
      removeEventListener: jest.fn(),
      throwIfAborted: jest.fn(),
      reason: undefined,
    },
    body: new ReadableStream({}),
    arrayBuffer: jest.fn(),
    blob: jest.fn(),
    bodyUsed: false,
    formData: jest.fn(),
    cf: {
      asn: 0,
      colo: "",
      country,
      asOrganization: "",
      botManagement: {
        corporateProxy: false,
        detectionIds: [],
        ja3Hash: "",
        verifiedBot: false,
        score: 0,
        staticResource: false,
      },
      city: "lisbon",
      clientTrustScore: 0,
      requestPriority: "",
      edgeRequestKeepAliveStatus,
      hostMetadata: {
        id: 0,
        name: "",
        region: "",
        status: "",
        type: "",
        __typename: "",
      },
      httpProtocol: "HTTP/1.1",
      tlsCipher: "",
      tlsVersion: "",
      tlsClientAuth: {
        certFingerprintSHA1: "",
        certFingerprintSHA256: "",
        certIssuerDN: "",
        certIssuerDNLegacy: "",
        certIssuerDNRFC2253: "",
        certIssuerSerial: "",
        certIssuerSKI: "",
        certNotAfter: "",
        certNotBefore: "",
        certPresented: "1" as const,
        certRevoked: "0" as const,
        certSerial: "",
        certSKI: "",
        certSubjectDN: "",
        certSubjectDNLegacy: "",
        certSubjectDNRFC2253: "",
        certVerified: "SUCCESS" as const,
      },
    },
    integrity: "",
    keepalive: false,
  },
  waitUntil: jest.fn(),
};
